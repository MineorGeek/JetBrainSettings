<application>
  <component name="AppStorage">
    <histories>
      <item value="registration" />
      <item value="allowing" />
      <item value="Extension to the standard {@link BeanFactoryPostProcessor} SPI, allowing for * the registration of further bean definitions &lt;i&gt;before&lt;/i&gt; regular * BeanFactoryPostProcessor detection kicks in. In particular, * BeanDefinitionRegistryPostProcessor may register further bean definitions * which in turn define BeanFactoryPostProcessor instances." />
      <item value="Extension" />
      <item value="omnibus" />
      <item value="机构行情购买" />
      <item value="expect" />
      <item value="aggregation" />
      <item value="聚合" />
      <item value="个人" />
      <item value="institution" />
      <item value="公司实体" />
      <item value="限制" />
      <item value="机构" />
      <item value="Separate Trading Limit Account" />
      <item value="Proprietary Trading Groups" />
      <item value="// The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue." />
      <item value="before tail and on head.next being accurate if the current" />
      <item value="The correctness of this depends on head being initialized" />
      <item value="invocation" />
      <item value="Convenience method to park and then check if interrupted * * @return {@code true} if interrupted" />
      <item value="Used by condition wait methods as well as acquire." />
      <item value="exclusive" />
      <item value="Acquires" />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire." />
      <item value="Try the fast path of enq" />
      <item value="uninterpreted" />
      <item value="the acquire argument. This value is conveyed to * {@link #tryAcquire} but is otherwise uninterpreted and * can represent anything you like." />
      <item value="Creates and enqueues node for current thread and given mode." />
      <item value="anticipation" />
      <item value="ongoing" />
      <item value="waitStatus value to indicate successor's thread needs unparking */" />
      <item value="Indicate that we * need a signal, but don't park yet." />
      <item value="PROPAGATE" />
      <item value="This node has already set status asking a release * to signal it, so it can safely park." />
      <item value="Head of the wait queue, lazily initialized. Except for * initialization, it is modified only via method setHead. Note: * If head exists, its waitStatus is guaranteed not to be * CANCELLED." />
      <item value="enqueues" />
      <item value="This class defines a nested {@link ConditionObject} class that * can be used as a {@link Condition} implementation by subclasses * supporting exclusive mode for which method {@link * #isHeldExclusively} reports whether synchronization is exclusively * held with respect to the current thread, method {@link #release} * invoked with the current {@link #getState} value fully releases * this object, and {@link #acquire}, given this saved state value, * eventually restores this object to its previous acquired state. No * {@code AbstractQueuedSynchronizer} method otherwise creates such a * condition, so if this constraint cannot be met, do not use it. The * behavior of {@link ConditionObject} depends of course on the * semantics of its synchronizer implementation." />
      <item value="nested" />
      <item value="Subclasses that support only exclusive or * only shared modes need not define the methods supporting the unused mode." />
      <item value="Usually, implementation subclasses support only * one of these modes, but both can come into play for example in a * {@link ReadWriteLock}." />
      <item value="This class * does not &amp;quot;understand&amp;quot; these differences except in the * mechanical sense that when a shared mode acquire succeeds, the next * waiting thread (if one exists) must also determine whether it can * acquire as well." />
      <item value="mechanical" />
      <item value="acquired" />
      <item value="Instead it defines methods such as * {@link #acquireInterruptibly} that can be invoked as * appropriate by concrete locks and related synchronizers to * implement their public methods." />
      <item value="appropriate" />
      <item value="synchronization" />
      <item value="enclosing" />
      <item value="respect" />
      <item value="tracked" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="208" />
        <entry key="ENGLISH" value="283" />
        <entry key="ARABIC" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="FRENCH" value="3" />
        <entry key="LATIN" value="1" />
        <entry key="JAPANESE" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5270ca83735d52d0" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>